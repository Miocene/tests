"use strict";(globalThis.webpackChunk_gitlab_ui=globalThis.webpackChunk_gitlab_ui||[]).push([[7197],{"./src/components/utilities/intersection_observer/intersection_observer.stories.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{BigTable:()=>BigTable,Default:()=>Default,InfiniteScrolling:()=>InfiniteScrolling,LazyLoadedImage:()=>LazyLoadedImage,default:()=>intersection_observer_stories});var intersection_observer=__webpack_require__("./src/components/utilities/intersection_observer/intersection_observer.vue"),components={GlIntersectionObserver:intersection_observer.default},commonData=()=>({isInView:!1}),commonMethods={appear(){this.isInView=!0},disappear(){this.isInView=!1}},generateItems=function(){var startingId=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Array.from(Array(20).keys()).map(index=>{var id=index+startingId+1;return{id,title:"Item ".concat(id)}})},Default=()=>({components,data:commonData,methods:commonMethods,computed:{visibility(){return this.isInView?"The observer is in view":"The observer is not in view"}},template:'\n    <div style="height: 200px; overflow-y: scroll;">\n      <h1>{{ visibility }}</h1>\n      <p>This one is a hard one to demonstrate as it\'s invisible by nature.</p>\n      <p>Underneath this block of text is an invisible component, <code>&lt;gl-observer /&gt;</code> that has the power to tell the vue app when it\'s visible, and when it\'s not.</p>\n      <p><strong>{{ visibility }}</strong>  at the moment but if you scroll and arrange your window just right, this can be changed and will be reflected in the title.</p>\n      <p :class="{\'gl-text-green-600\': isInView }">To make it even more clear, this line of text will be green when the element scrolls into view.</p>\n      <p>This line appears just before the observer.</p>\n      <gl-intersection-observer\n        @appear="appear"\n        @disappear="disappear"\n      />\n      <p>This line appears just after the observer.</p>\n    </div>\n  '}),BigTable=()=>({components,data:()=>({values:Array(100).fill(1).map(()=>Array(10).fill(0))}),methods:{update(row,col,_ref){var{intersectionRatio}=_ref;this.$set(this.values[row],col,intersectionRatio)},disappear(row,col){this.values[row][col]=0}},template:'\n    <div style="height: 600px; overflow-y: scroll;">\n      <table>\n        <tr v-for="(cols, row) in values" :key="row">\n          <td v-for="(value, col) in cols" :key="row + \'_\' + col">\n            <gl-intersection-observer @update="update(row, col, $event)">\n              <span :style="{ display: \'inline-block\', width: \'50px\' }">{{ value.toString().substr(0, 3) }}</span>\n            </gl-intersection-observer>\n          </td>\n        </tr>\n      </table>\n    </div>\n    '}),LazyLoadedImage=()=>({components,data:commonData,methods:commonMethods,computed:{imageUrl(){return this.isInView?"../../img/gitlab-summit-south-africa.jpg":"../../img/gitlab-summit-south-africa-min.jpg"}},template:'\n    <div>\n      <p>The image below will load a low-res version until it appears on the poage, then it will switch out for a higher res version.</p>\n      <p>It\'s also set up to switch back to the low res version when it disappears off the page. This is not what you would usually do for lazily loaded images, but it helps to demonstrate the effect in this example.</p>\n      <gl-intersection-observer\n        @appear="appear"\n        @disappear="disappear"\n      >\n        <img :src="imageUrl" style="max-width: 100%; height: auto;"/>\n      </gl-intersection-observer>\n    </div>\n  '}),InfiniteScrolling=()=>({components,data:()=>({items:generateItems()}),computed:{lastItemId(){return this.items[this.items.length-1].id},endOfList(){return this.lastItemId>=1e3}},methods:{fetchMoreItems(){this.endOfList||this.items.push(...generateItems(this.lastItemId))}},template:'\n    <div>\n      <h2>Infinitely scrollable list</h2>\n      <p>This data will procedurally generate 1000 items, 20 at a time</p>\n      <ul>\n        <li v-for="item in items" :key="item.id">{{ item.title }}</li>\n      </ul>\n      <gl-intersection-observer v-if="!endOfList" @appear="fetchMoreItems">\n        <button @click="fetchMoreItems">Fetch more items</button>\n      </gl-intersection-observer>\n    </div>\n'});let intersection_observer_stories={title:"utilities/intersection-observer",component:intersection_observer.default,tags:["skip-visual-test"],parameters:{docs:{description:{component:"This intersection observer component is an invisible watcher that emits events when it appears and\ndissapears from view.\n\nIt acts a a vue-friendly wrapper around the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n\nBecause of it's simplicity you can use it for a lot of different things.\nIt's especially helpful for the lazy loading of images, and infinite scrolling of lists.\n\nAnything slotted inside this component will become the element that is being observed.\n\nThis slot can also be used as a fallback for the browsers that don't support the intersection\nobserver, or in the case that the observer fails to work.\nFor example, adding a \"Fetch more posts\" button inside an observer that should fetch more posts\nautomatically when visible. If the observer fails to work for any reason, the button will still be\nclickable, and the experience preserved. Please use a fallback wherever possible as\n**the intersection observer API is not supported in IE11**.\n"}}}};Default.parameters={...Default.parameters,docs:{...Default.parameters?.docs,source:{originalSource:"() => ({\n  components,\n  data: commonData,\n  methods: commonMethods,\n  computed: {\n    visibility() {\n      return this.isInView ? 'The observer is in view' : 'The observer is not in view';\n    }\n  },\n  template: `\n    <div style=\"height: 200px; overflow-y: scroll;\">\n      <h1>{{ visibility }}</h1>\n      <p>This one is a hard one to demonstrate as it's invisible by nature.</p>\n      <p>Underneath this block of text is an invisible component, <code>&lt;gl-observer /&gt;</code> that has the power to tell the vue app when it's visible, and when it's not.</p>\n      <p><strong>{{ visibility }}</strong>  at the moment but if you scroll and arrange your window just right, this can be changed and will be reflected in the title.</p>\n      <p :class=\"{'gl-text-green-600': isInView }\">To make it even more clear, this line of text will be green when the element scrolls into view.</p>\n      <p>This line appears just before the observer.</p>\n      <gl-intersection-observer\n        @appear=\"appear\"\n        @disappear=\"disappear\"\n      />\n      <p>This line appears just after the observer.</p>\n    </div>\n  `\n})",...Default.parameters?.docs?.source}}},BigTable.parameters={...BigTable.parameters,docs:{...BigTable.parameters?.docs,source:{originalSource:'() => ({\n  components,\n  data() {\n    return {\n      values: Array(100).fill(1).map(() => Array(10).fill(0))\n    };\n  },\n  methods: {\n    update(row, col, {\n      intersectionRatio\n    }) {\n      this.$set(this.values[row], col, intersectionRatio);\n    },\n    disappear(row, col) {\n      this.values[row][col] = 0;\n    }\n  },\n  template: `\n    <div style="height: 600px; overflow-y: scroll;">\n      <table>\n        <tr v-for="(cols, row) in values" :key="row">\n          <td v-for="(value, col) in cols" :key="row + \'_\' + col">\n            <gl-intersection-observer @update="update(row, col, $event)">\n              <span :style="{ display: \'inline-block\', width: \'50px\' }">{{ value.toString().substr(0, 3) }}</span>\n            </gl-intersection-observer>\n          </td>\n        </tr>\n      </table>\n    </div>\n    `\n})',...BigTable.parameters?.docs?.source}}},LazyLoadedImage.parameters={...LazyLoadedImage.parameters,docs:{...LazyLoadedImage.parameters?.docs,source:{originalSource:'() => ({\n  components,\n  data: commonData,\n  methods: commonMethods,\n  computed: {\n    imageUrl() {\n      // If the image is in view, return the high res one. If not return nothing, or a low res one\n      return this.isInView ? \'../../img/gitlab-summit-south-africa.jpg\' : \'../../img/gitlab-summit-south-africa-min.jpg\';\n    }\n  },\n  template: `\n    <div>\n      <p>The image below will load a low-res version until it appears on the poage, then it will switch out for a higher res version.</p>\n      <p>It\'s also set up to switch back to the low res version when it disappears off the page. This is not what you would usually do for lazily loaded images, but it helps to demonstrate the effect in this example.</p>\n      <gl-intersection-observer\n        @appear="appear"\n        @disappear="disappear"\n      >\n        <img :src="imageUrl" style="max-width: 100%; height: auto;"/>\n      </gl-intersection-observer>\n    </div>\n  `\n})',...LazyLoadedImage.parameters?.docs?.source}}},InfiniteScrolling.parameters={...InfiniteScrolling.parameters,docs:{...InfiniteScrolling.parameters?.docs,source:{originalSource:'() => ({\n  components,\n  data: () => ({\n    items: generateItems()\n  }),\n  computed: {\n    lastItemId() {\n      return this.items[this.items.length - 1].id;\n    },\n    endOfList() {\n      return this.lastItemId >= 1000;\n    }\n  },\n  methods: {\n    fetchMoreItems() {\n      if (!this.endOfList) {\n        this.items.push(...generateItems(this.lastItemId));\n      }\n    }\n  },\n  template: `\n    <div>\n      <h2>Infinitely scrollable list</h2>\n      <p>This data will procedurally generate 1000 items, 20 at a time</p>\n      <ul>\n        <li v-for="item in items" :key="item.id">{{ item.title }}</li>\n      </ul>\n      <gl-intersection-observer v-if="!endOfList" @appear="fetchMoreItems">\n        <button @click="fetchMoreItems">Fetch more items</button>\n      </gl-intersection-observer>\n    </div>\n`\n})',...InfiniteScrolling.parameters?.docs?.source}}}}}]);